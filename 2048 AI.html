<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1rem;
            background-color: #4a5568; /* gray-600 */
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
        }
        .grid-cell {
            background-color: #718096; /* gray-500 */
            border-radius: 0.25rem;
            width: 100%;
            padding-bottom: 100%; /* Aspect ratio 1:1 */
        }
        .tile {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 0.25rem;
            transition: all 0.15s ease-in-out;
            color: white;
        }
        .info-box {
            background-color: #2d3748; /* bg-gray-700 */
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto">
        <h1 class="text-3xl font-bold text-center mb-2 text-orange-400">AI Plays 2048-Lite</h1>
        <p class="text-center text-gray-400 mb-4">A Q-learning agent is learning to play this complex puzzle game.</p>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
            <div class="info-box text-center">
                <span class="font-bold text-lg">Episode</span><br>
                <span id="episode-count">0</span>
            </div>
            <div class="info-box text-center">
                <span class="font-bold text-lg">Score</span><br>
                <span id="score">0</span>
            </div>
            <div class="info-box text-center">
                <span class="font-bold text-lg">Max Score</span><br>
                <span id="max-score">0</span>
            </div>
            <div class="info-box text-center">
                <span class="font-bold text-lg">Max Tile</span><br>
                <span id="max-tile">0</span>
            </div>
        </div>

        <div id="game-board" class="grid-container w-full aspect-square shadow-2xl shadow-orange-500/20">
            <!-- Grid cells will be generated by JS -->
        </div>
        
        <div class="mt-4 flex justify-center items-center gap-4">
            <button id="speed-control" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg">Speed Up Training</button>
            <button id="reset-ai" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Reset AI Memory</button>
        </div>
        
        <div class="info-box mt-4 text-sm">
            <h2 class="font-bold text-lg mb-2">How it works:</h2>
            <p><strong class="text-orange-400">State:</strong> The AI "sees" the board as a sequence of 16 numbers, representing the log2 value of each tile (e.g., 2 becomes 1, 8 becomes 3, etc.). This simplifies the vast number of possible board configurations.</p>
            <p><strong class="text-orange-400">Actions:</strong> The AI can choose one of four actions: slide Up, Down, Left, or Right.</p>
            <p><strong class="text-orange-400">Reward:</strong> The AI is rewarded with the value of any new tiles created by a merge (e.g., merging two 8s gives a reward of 16). This encourages it to make productive moves.</p>
            <p class="mt-2"><strong class="text-yellow-400">Epsilon (Îµ):</strong> The AI's exploration rate. It starts high and slowly decreases, shifting the AI from making random moves to using its learned strategy. Current Epsilon: <span id="epsilon-value">1.00</span></p>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Game Setup & UI Elements ---
        const gameBoardEl = document.getElementById('game-board');
        const scoreEl = document.getElementById('score');
        const episodeEl = document.getElementById('episode-count');
        const maxScoreEl = document.getElementById('max-score');
        const maxTileEl = document.getElementById('max-tile');
        const epsilonEl = document.getElementById('epsilon-value');
        const speedBtn = document.getElementById('speed-control');
        const resetBtn = document.getElementById('reset-ai');

        const TILE_COLORS = {
            2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
            32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
            512: '#edc850', 1024: '#edc53f', 2048: '#edc22e', 4096: '#3c3a32'
        };
        const TILE_TEXT_COLORS = { 2: '#776e65', 4: '#776e65', default: '#f9f6f2' };

        // --- Game Logic ---
        class Game2048 {
            constructor() {
                this.gridSize = 4;
                this.board = this.createEmptyBoard();
                this.score = 0;
            }

            createEmptyBoard() {
                return Array.from({ length: this.gridSize }, () => Array(this.gridSize).fill(0));
            }

            reset() {
                this.board = this.createEmptyBoard();
                this.score = 0;
                this.addRandomTile();
                this.addRandomTile();
            }

            getEmptyCells() {
                const cells = [];
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (this.board[r][c] === 0) cells.push({ r, c });
                    }
                }
                return cells;
            }

            addRandomTile() {
                const emptyCells = this.getEmptyCells();
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    this.board[cell.r][cell.c] = value;
                }
            }

            move(direction) { // 0: up, 1: right, 2: down, 3: left
                let moved = false;
                let moveScore = 0;
                let tempBoard = JSON.parse(JSON.stringify(this.board));

                // Rotate board to always handle move as a 'left' slide
                if (direction === 0) tempBoard = this.rotate(tempBoard, 1); // up -> left
                if (direction === 1) tempBoard = this.rotate(tempBoard, 2); // right -> left
                if (direction === 2) tempBoard = this.rotate(tempBoard, 3); // down -> left
                
                for (let r = 0; r < this.gridSize; r++) {
                    const row = tempBoard[r].filter(val => val !== 0);
                    const newRow = [];
                    for (let i = 0; i < row.length; i++) {
                        if (i + 1 < row.length && row[i] === row[i + 1]) {
                            const mergedValue = row[i] * 2;
                            newRow.push(mergedValue);
                            moveScore += mergedValue;
                            i++; // Skip next tile
                        } else {
                            newRow.push(row[i]);
                        }
                    }
                    // Pad with zeros
                    while (newRow.length < this.gridSize) newRow.push(0);
                    tempBoard[r] = newRow;
                }

                // Rotate back
                if (direction === 0) tempBoard = this.rotate(tempBoard, 3); // left -> up
                if (direction === 1) tempBoard = this.rotate(tempBoard, 2); // left -> right
                if (direction === 2) tempBoard = this.rotate(tempBoard, 1); // left -> down

                if (JSON.stringify(this.board) !== JSON.stringify(tempBoard)) {
                    this.board = tempBoard;
                    this.score += moveScore;
                    moved = true;
                }
                
                return { moved, moveScore };
            }
            
            rotate(matrix, times) {
                let m = JSON.parse(JSON.stringify(matrix));
                for (let t = 0; t < times; t++) {
                    m = m[0].map((val, index) => m.map(row => row[index]).reverse());
                }
                return m;
            }

            isGameOver() {
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (this.board[r][c] === 0) return false; // Empty cell exists
                        if (r < this.gridSize - 1 && this.board[r][c] === this.board[r + 1][c]) return false; // Can merge down
                        if (c < this.gridSize - 1 && this.board[r][c] === this.board[r][c + 1]) return false; // Can merge right
                    }
                }
                return true;
            }
            
            getMaxTile() {
                return Math.max(...this.board.flat());
            }
        }

        // --- AI Agent ---
        class QLearningAgent {
            constructor() {
                this.qTable = {};
                this.alpha = 0.1; // Learning rate
                this.gamma = 0.9; // Discount factor
                this.epsilon = 1.0;
                this.epsilonDecay = 0.9995;
                this.epsilonMin = 0.01;
                this.actions = [0, 1, 2, 3]; // up, right, down, left
            }

            getState(board) {
                // Convert tile values to log2, 0 for empty. This simplifies the state.
                return board.flat().map(v => v === 0 ? 0 : Math.log2(v)).join('_');
            }

            chooseAction(state, validMoves) {
                if (Math.random() < this.epsilon) {
                    return validMoves[Math.floor(Math.random() * validMoves.length)];
                }
                const qValues = this.qTable[state] || [0, 0, 0, 0];
                let bestAction = -1;
                let maxQ = -Infinity;
                // Find best valid action
                for (const action of validMoves) {
                    if (qValues[action] > maxQ) {
                        maxQ = qValues[action];
                        bestAction = action;
                    }
                }
                return bestAction;
            }

            learn(state, action, reward, nextState) {
                const oldQ = this.qTable[state]?.[action] || 0;
                const nextQValues = this.qTable[nextState] || [0, 0, 0, 0];
                const maxNextQ = Math.max(...nextQValues);
                const newQ = oldQ + this.alpha * (reward + this.gamma * maxNextQ - oldQ);

                if (!this.qTable[state]) this.qTable[state] = [0, 0, 0, 0];
                this.qTable[state][action] = newQ;
            }

            decayEpsilon() {
                if (this.epsilon > this.epsilonMin) this.epsilon *= this.epsilonDecay;
            }
            
            reset() {
                this.qTable = {};
                this.epsilon = 1.0;
            }
        }

        // --- Game Manager ---
        let game = new Game2048();
        let ai = new QLearningAgent();
        let episode = 0;
        let maxScore = 0;
        let maxTileOverall = 0;
        let gameSpeed = 1; // 1 for slow, higher for fast
        let isRunning = false;

        function renderBoard() {
            gameBoardEl.innerHTML = '';
            for (let r = 0; r < game.gridSize; r++) {
                for (let c = 0; c < game.gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    gameBoardEl.appendChild(cell);

                    const value = game.board[r][c];
                    if (value > 0) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.textContent = value;
                        const size = 100 / game.gridSize;
                        tile.style.width = `calc(${size}% - 2rem)`;
                        tile.style.height = `calc(${size}% - 2rem)`;
                        tile.style.top = `calc(${r * size}% + 1rem)`;
                        tile.style.left = `calc(${c * size}% + 1rem)`;
                        
                        const color = TILE_COLORS[value] || TILE_COLORS[4096];
                        const textColor = TILE_TEXT_COLORS[value] || TILE_TEXT_COLORS.default;
                        tile.style.backgroundColor = color;
                        tile.style.color = textColor;
                        tile.style.fontSize = `${Math.max(1, 2.5 - Math.log10(value))}rem`;
                        
                        gameBoardEl.appendChild(tile);
                    }
                }
            }
        }

        function updateUI() {
            scoreEl.textContent = game.score;
            episodeEl.textContent = episode;
            maxScoreEl.textContent = maxScore;
            maxTileEl.textContent = maxTileOverall;
            epsilonEl.textContent = ai.epsilon.toFixed(4);
        }
        
        function getValidMoves() {
            const validMoves = [];
            for (const action of ai.actions) {
                const tempGame = new Game2048();
                tempGame.board = JSON.parse(JSON.stringify(game.board));
                if (tempGame.move(action).moved) {
                    validMoves.push(action);
                }
            }
            return validMoves;
        }

        async function runAIEpisode() {
            if (!isRunning) return;
            game.reset();
            let gameOver = false;

            while (!gameOver) {
                const state = ai.getState(game.board);
                const validMoves = getValidMoves();

                if (validMoves.length === 0) {
                    gameOver = true;
                    break;
                }

                const action = ai.chooseAction(state, validMoves);
                const { moved, moveScore } = game.move(action);

                if (moved) {
                    game.addRandomTile();
                    const nextState = ai.getState(game.board);
                    ai.learn(state, action, moveScore, nextState);
                }
                
                if (gameSpeed === 1) {
                    renderBoard();
                    updateUI();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                if (game.isGameOver()) {
                    gameOver = true;
                }
            }

            // Episode finished
            if (game.score > maxScore) maxScore = game.score;
            const currentMaxTile = game.getMaxTile();
            if (currentMaxTile > maxTileOverall) maxTileOverall = currentMaxTile;
            
            ai.decayEpsilon();
            episode++;
            updateUI();
            
            // Fast mode loop
            if (gameSpeed > 1) {
                requestAnimationFrame(runAIEpisode);
            } else {
                setTimeout(runAIEpisode, 500); // Pause before next slow-mo game
            }
        }
        
        // --- Controls ---
        speedBtn.addEventListener('click', () => {
            if (gameSpeed === 1) {
                gameSpeed = 100; // Fast mode
                speedBtn.textContent = 'Normal Speed';
                speedBtn.classList.replace('bg-orange-500', 'bg-yellow-500');
                speedBtn.classList.replace('hover:bg-orange-600', 'hover:bg-yellow-600');
                if (!isRunning) {
                    isRunning = true;
                    runAIEpisode();
                }
            } else {
                gameSpeed = 1; // Normal speed
                speedBtn.textContent = 'Speed Up Training';
                speedBtn.classList.replace('bg-yellow-500', 'bg-orange-500');
                speedBtn.classList.replace('hover:bg-yellow-600', 'hover:bg-orange-600');
            }
        });

        resetBtn.addEventListener('click', () => {
            ai.reset();
            episode = 0;
            maxScore = 0;
            maxTileOverall = 0;
            game.reset();
            renderBoard();
            updateUI();
        });

        // --- Start ---
        isRunning = true;
        runAIEpisode();
    });
    </script>
</body>
</html>